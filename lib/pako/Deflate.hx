package pako;

import haxe.extern.EitherType;

/**
 * Generic JS-style wrapper for zlib calls.
 * 
 * If you don't need streaming behaviour - use more simple functions: `Pako.deflate()`, `Pako.deflateRaw()` and `Pako.gzip()`.
 * ```
 * var chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9]);
 * var chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 * 
 * var deflate = new Deflate({ level: 3 });
 * 
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 * 
 * if (deflate.err) { throw new Error(deflate.err); }
 * 
 * trace(deflate.result);
 * ```
 * @see Documentation: http://nodeca.github.io/pako/#Deflate
 */
@:native("pako.Deflate")
extern class Deflate
{
    /**
     * Creates new deflator instance with specified params.
     * Throws exception on bad params.
     * @param options Deflate options.
     * @see Doc: http://nodeca.github.io/pako/#Deflate.new
     */
    public function new(?options:Options);

    /**
     * Error code after deflate finished.
     * Value `StatusCode.OK` - on success.
     * 
     * You will not need it in real life, because deflate errors are possible only on wrong
     * options or bad onData / onEnd custom handlers.
     * @see Doc: http://nodeca.github.io/pako/#Deflate.err
     */
    public var err(default, null):StatusCode;

    /**
     * Error message, if `Deflate.err != StatusCode.OK`.
     * @see Doc: http://nodeca.github.io/pako/#Deflate.msg
     */
    public var msg(default, null):String;

    /**
     * Compressed result, generated by default `Deflate.onData` and `Deflate.onEnd` handlers.
     * Filled after you push last chunk (call `Deflate.push()` with `FlushMode.FINISH` / `true` param) or
     * if you push a chunk with explicit flush (call `Deflate.push()` with `FlushMode.SYNC_FLUSH` param).
     * @see Doc: http://nodeca.github.io/pako/#Deflate.result
     */
    public var result(default, null):Chunk;

    /**
     * By default, stores data blocks in `chunks[]` property and glue those in `onEnd()`.
     * Override this handler, if you need another behaviour.
     * @see Doc: http://nodeca.github.io/pako/#Deflate.prototype.onData
     */
    public var onData:Chunk->Void;

    /**
     * Called once after you tell deflate that the input stream is complete (`StatusCode.FINISH`) or should
     * be flushed (`FlushMode.SYNC_FLUSH`) or if an error happened. By default - join collected chunks, free
     * memory and fill results / err properties.
     * @see Doc: http://nodeca.github.io/pako/#Deflate.prototype.onEnd
     */
    public var onEnd:StatusCode->Void;

    /**
     * Sends input data to deflate pipe, generating Deflate#onData calls with new compressed chunks.
     * 
     * The last data block must have mode `FlushMode.FINISH` (or `true`). That will flush internal pending
     * buffers and call `Deflate.onEnd()`. For interim explicit flushes (without ending the stream) you can
     * use mode `FlushMode.SYNC_FLUSH`, keeping the compression context.
     * 
     * On fail call `Deflate.onEnd()` with error code and return false.
     * 
     * We **strongly recommend** to use Uint8Array on input for best speed (output array format is detected
     * automatically). Also, don't skip last param and always use the same type in your code (boolean or
     * number). That will improve JS speed.
     * 
     * For regular Array-s make sure all elements are [0..255].
     * 
     * ```
     * push(chunk, false); // push one of data chunk
     * ...
     * push(chunk, true);  // push last chunk
     * ```
     * @param data Input data. Strings will be converted to utf8 byte sequence.
     * @param mode Corresponding flush modes. Skipped or false means `FlushMode.NO_FLUSH`, true means `FlushMode.FINISH`.
     * @return Bool Returns true on success. On fail call `Deflate.onEnd()` with error code and return false.
     * @see Doc: http://nodeca.github.io/pako/#Deflate.prototype.push
     */
    public function push(data:Chunk, mode:EitherType<FlushMode, Bool> = FlushMode.NO_FLUSH):Bool;
}